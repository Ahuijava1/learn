## 六大设计原则

### 1. 单一职责原则

**定义**：应该有且仅有一个原因引起类的变更

一个接口是否只负责一件事？是否只有一个原因引起变化？

**好处：**

1. 类的复杂性降低，实现什么职责都有清晰明确的定义
2. 可读性提高，复杂性降低，那当然可读性提高了
3. 可维护性提高
4. 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。

**缺点：**很难做到

### 2. 里氏替换原则

**定义：**

1. 如果对每个类型为**S**的对象**o1**，都有类型为**T**的对象**o2**，使得以T定义的所有程序**P**在所有的对象**o1**都代换成**o2**时，程序**P**的行为没有发生变化，那么类型**S**是类型**T**的子类型。（子类可以替换父类）
2. 所用引用基类的地方必须能透明地使用其子类的对象。

**定义（总结）：**

1. 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法
2. 子类中可以增加自己持有的方法
3. 当子类的方法重载父类的方法时，方法的前置条件（参数）要比父类的方法更宽松
4. 当子类的方法实现父类的方法时，方法的返回值要比父类更严格或者相等。

**作用：**

1. 里氏替换原则是实现开闭原则的重要方式之一
2. 它克服了继承中重写父类造成的可复用性变差的缺点
3. 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。
4. 加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。

**实现方法：**

​	通俗来讲，就是子类可以扩展父类的功能，但不能改变父类原有的功能，也就是不能重写父类的方法。

### 3. 依赖倒置原则

**定义：**

1. 高层模块不应该依赖低层模块，两者都应该依赖其抽象。
2. 抽象不应该依赖细节
3. 细节应该依赖抽象

抽象就是接口或抽象类，细节就是实现类。

**Java中的表现：**

+ 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或者抽象类产生的。
+ 接口或者抽象类不依赖实现类
+ 实现类依赖接口或者抽象类

**依赖的三种写法：**

​	依赖是可以传递的！

1. 构造函数传递依赖对象
2. Setter方法传递依赖对象
3. 接口声明依赖对象

**总结：**依赖倒置的本质就是通过抽象使各个类或者模块的实现彼此独立，不互相影响，实现模块间的松耦合。

+ 每个类尽量都有接口或者抽象类，或者二者都有
+ 变量的表面类型尽量是接口或者抽象类
+ 任何类都不应该从具体类派生
+ 尽量不要重写基类的方法
+ 结合里氏替换原则使用

### 4. 接口隔离原则

**定义：**

1. 客户端不应该依赖它不需要的接口。
2. 类间的依赖关系应该建立在最小的接口上

### 5. **迪米特法制**

**定义：**一个对象应该对其他对象有最少的了解。

1. 只和朋友聊天（这里的朋友指的是依赖的对象，出现在成员变量、方法的输入输出参数的类才能称为成员朋友类）
2. 朋友之间也是有隔离的（尽量不要提供太多的public方法给朋友）
3. 是自己的就是自己的（如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。）
4. 谨慎使用Serializable（这问题应该属于项目管理范畴）

### 6. 开闭原则

**定义：**一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。（当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。）

***	开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段。***

