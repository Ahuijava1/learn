**三个问题：**

1. 哪些内存需要回收？
2. 什么时候回收？
3. 怎么回收内存？



## 3.2 哪些内存需要回收？

​	一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件的分支所需要的内存也可能不一样。只有处于运行期间，我们才能知道程序需要创建哪些对象。

### 3.2.1 引用计数算法

​	在对象中创建一个引用计数器，每个有一个地方引用它的时候，计数器加一。当引用失效时，计数器减一。任何时刻计数器为零的对象就是不可能被使用的。

优点：高效

缺点：情况多种多样，比如相互循环问题

```java
Obj a = new Obj();
Obj b = new Obj();
a.instance = b;
b.instance = a;
```

### 3.2.2 可达性分析算法

​	通过一系列的“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链连接，那么证明此对象时不可能被使用。

#### 怎么判断是GC Roots？

1.  在虚拟机栈（栈帧中的本地变量表）中引用的对象，比如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
2. 在方法区中类静态属性引用的对象，比如Java类的引用类型静态变量。
3. 在方法区中常量引用的对象，比如字符串常量池（String Table）里的引用。
4. 在本地方法栈中JNI（Native方法）引用的对象。
5. Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NPE，OOM）等，还有系统类加载器。
6. 所用被同步锁持有的对象。
7. 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

> ​	在分代收集和局部回收时，有可能这些区域被堆中的其它区域所引用。这时需要将这些关联区域的对象也一起加入到GC Roots中。

### 3.2.3 再谈引用

1. 强引用

   ```java
   /**
    * 强引用
    *      如果一个对象具有强引用，那就类似于必不可少的物品，不会被垃圾回收器回收。
    *      当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。
    *
    *      如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为null，
    *      这样一来的话，JVM在合适的时间就会回收该对象。
    * @author ZhengChaoHui
    * @Date 2020/6/30 8:47
    */
   public class StrongRef {
       public static void main(String[] args) {
           StrongRef.m1();
       }
       public static void m1(){
           Object o = new Object();
           Object[] objects = new Object[Integer.MAX_VALUE];
       }
   }
   
   执行报错：
       Exception in thread "main" java.lang.OutOfMemoryError: Requested array size exceeds VM limit
   	at references.StrongRef.m1(StrongRef.java:19)
   	at references.StrongRef.main(StrongRef.java:15)
           
   ```

2. 软引用

   ```java
   /**
    * 软引用
    *      软引用是用来描述一些有用但并不是必需的对象，在Java中用java.lang.ref.SoftReference类来表示。
    *      对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。
    *      因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。
    *
    *      软引用可以和一个引用队列（ReferenceQueue）联合使用，
    *      如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。
    * @author ZhengChaoHui
    * @Date 2020/6/29 19:42
    */
   @SuppressWarnings("all")
   public class SoftRef {
       public static void main(String[] args) {
           Obj obj = new Obj();
           SoftReference<Obj> sr = new SoftReference<Obj>(obj);
           obj = null;
           System.out.println(sr.get());
       }
   }
   class Obj{
       int[] obj;
       public Obj(){
           obj = new int[1000];
       }
   }
   ```

3. 弱引用

   ```java
   /**
    * 弱引用
    *      弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。
    *      在java中，用java.lang.ref.WeakReference类来表示。
    *      弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。
    *      在垃圾回收器线程扫描它所管辖的内存区域的过程中，
    *      一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。
    *      不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。
    *      软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。
    * @author ZhengChaoHui
    * @Date 2020/6/29 19:46
    */
   public class WeakRef {
       public static void main(String[] args) {
           WeakReference<String> wr = new WeakReference<String>(new String("Hello"));
           //输出Hello
           System.out.println(wr.get());
           //通知jvm回收（这句是无法确保此时JVM一定会进行垃圾回收的）
           System.gc();
           //输出null
           System.out.println(wr.get());
       }
   }
   ```

4. 虚引用

   ```java
   /**
    * 虚引用
    *      虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。
    *      在java中用java.lang.ref.PhantomReference类表示。
    *      如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。
    *      虚引用主要用来跟踪对象被垃圾回收的活动。
    *      *虚引用必须和引用队列关联使用*
    * @author ZhengChaoHui
    * @Date 2020/6/30 8:56
    */
   public class PhantomRef {
   
       public static void main(String[] args) {
           ReferenceQueue<String> queue = new ReferenceQueue< >();
           System.out.println(queue.poll());
           PhantomReference<String> ptr = new PhantomReference<>(new String("hello"), queue);
           System.out.println(queue.poll());
           System.out.println(ptr.get());
       }
   }
   
   输出：null
        null
   ```

**参考文章：**

[*Java基础篇 - 强引用、弱引用、软引用和虚引用*](https://blog.csdn.net/baidu_22254181/article/details/81979663)

